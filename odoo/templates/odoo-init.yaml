apiVersion: v1
kind: ConfigMap
metadata:
  name: pull-production-db
  namespace: {{ .Release.Namespace }}
data:
  pull-production-db.sh: |
    #!/bin/bash

    if [ ! -f /mnt/prod-backup/done ]; then
      apk add --no-cache curl

      BACKUP_FILE="/mnt/prod-backup/backup.zip"
      EXTRACT_DIR="/mnt/prod-backup/unzipped"


      if [ -f "$BACKUP_FILE" ]; then
        rm "$BACKUP_FILE"
      fi
      curl -o "$BACKUP_FILE" -X POST \
        -F "master_pwd=$MASTER_PW" \
        -F"name=$PROD_DB" \
        -F "backup_format=zip" \
        "http://$PROD_HOST/web/database/backup"

      if [ ! -d $EXTRACT_DIR ]; then
        mkdir -p $EXTRACT_DIR
      else
        rm -rf $EXTRACT_DIR/*
      fi

      unzip "$BACKUP_FILE" -d "$EXTRACT_DIR"
      rm "$BACKUP_FILE"
      chmod -R 777 /mnt/prod-backup
    fi

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: restore-db
  namespace: {{ .Release.Namespace }}
data:
  restore-db.sh: |
    #!/bin/bash
    if [ ! -f /mnt/prod-backup/done ]; then

      BACKUP_FILE="/mnt/prod-backup/backup.zip"
      EXTRACT_DIR="/mnt/prod-backup/unzipped"

      # Function to restore the database
      restore_database() {
        echo "Restoring database $DB_NAME..."
        createdb -U "$PG_USER" -h "$PG_HOST" "$DB_NAME"
        psql -U "$PG_USER" -h "$PG_HOST" -d "$DB_NAME" -f "$EXTRACT_DIR/dump.sql"
      }

      # Function to copy the filestore
      copy_filestore() {
        echo "Copying filestore to $FILESTORE_DEST_DIR/$DB_NAME..."
        if [ ! -d "$FILESTORE_DEST_DIR" ]; then
          mkdir -p "$FILESTORE_DEST_DIR" ]
        fi
        cp -r "$EXTRACT_DIR/filestore" "$FILESTORE_DEST_DIR/$DB_NAME"
      }

      # Check if the database already exists
      if psql -U "$PG_USER" -h "$PG_HOST" -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
        echo "Database $DB_NAME already exists. Dropping database."
        dropdb -U "$PG_USER" -h "$PG_HOST" "$DB_NAME"
      fi
      restore_database

      # Check if the filestore for the database already exists
      if [ -d "$FILESTORE_DEST_DIR/$DB_NAME" ]; then
        echo "Filestore for $DB_NAME already exists. Deleting."
        rm -rf "$FILESTORE_DEST_DIR/$DB_NAME"
      fi
      echo "Copying filestore..."
      copy_filestore
      chown -R odoo:odoo /var/lib/odoo

      touch /mnt/prod-backup/done
    fi

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: init-db-script
  namespace: {{ .Release.Namespace }}
data:
  init-db-user.sh: |
    #!/bin/bash
    set -e

    # Environment variables passed to the container
    HOST=${HOST}
    USER=${USER}
    PASSWORD=${PASSWORD}

    psql -v ON_ERROR_STOP=1 --host="$HOST" --username="postgres" --dbname="postgres" <<-EOSQL
    DO \$\$
    BEGIN
      IF NOT EXISTS (SELECT FROM pg_catalog.pg_user WHERE usename = '$USER') THEN
        CREATE USER $USER WITH PASSWORD '$PASSWORD' CREATEDB;
      END IF;
    END
    \$\$;
    EOSQL

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: git-pull-addons
  namespace: {{ .Release.Namespace }}
data:
  git-pull-addons.sh: |
    #!/bin/bash
    set -ex

    REPO_DIR="/mnt/repo"
    EXTRA_ADDONS_DIR="/mnt/extra-addons"
    SSH_DIR="/root/.ssh"
    export GIT_SSH_COMMAND="ssh -o StrictHostKeyChecking=no"

    # Ensure the SSH directory exists and is properly set up
    mkdir -p $SSH_DIR
    cp /mnt/secrets/ssh-privatekey $SSH_DIR/privatekey
    chmod 600 $SSH_DIR/privatekey
    eval "$(ssh-agent -s)"
    ssh-add $SSH_DIR/privatekey

    # Detect the format of REPO_URL and extract the host accordingly
    if [[ $REPO_URL == git@* ]]; then
      # Handle git@repo.domain.name:org/repo.git format
      GIT_HOST=$(echo $REPO_URL | awk -F'[@:]' '{print $2}')
    elif [[ $REPO_URL == https://* ]]; then
      # Handle https://repo.domain.name/org/repo.git format
      GIT_HOST=$(echo $REPO_URL | awk -F'[/:]' '{print $4}')
    else
      echo "Unsupported REPO_URL format: $REPO_URL"
      exit 1
    fi

    echo "Using GIT_HOST: $GIT_HOST"

    # Add the Git host to known_hosts
    # ssh-keyscan $GIT_HOST >> $SSH_DIR/known_hosts

    # Clear the /mnt/extra-addons directory
    rm -rf $EXTRA_ADDONS_DIR/*
    mkdir -p $EXTRA_ADDONS_DIR

    # Function to clone or update a repo
    clone_or_update_repo() {
      local repo_url="$1"
      local branch="$2"
      local commit="$3"
      local target_dir="$4"

      if [ -d "$target_dir/.git" ]; then
        echo "Repository $repo_url already exists. Fetching latest changes."
        cd "$target_dir"
        git fetch origin "$branch"
        if [ -n "$commit" ]; then
          git reset --hard --recurse-submodules "$commit"
        else
          git reset --hard --recurse-submodules origin/$branch
        fi
      else
        echo "Cloning repository $repo_url."
        git clone --recurse-submodules -b "$branch" "$repo_url" "$target_dir"
        cd "$target_dir"
        if [ -n "$commit" ]; then
          git reset --hard --recurse-submodules $commit
        fi
      fi
    }

    # Clone or update the main Odoo repository
    clone_or_update_repo "$REPO_URL" "$BRANCH" "$COMMIT" "$REPO_DIR/project"

    # Optionally clone or update the Odoo enterprise repository
    if [ -n "$ENTERPRISE_REPO_URL" ]; then
      # ssh-keyscan github.com >> $SSH_DIR/known_hosts
      clone_or_update_repo "$ENTERPRISE_REPO_URL" "$ENTERPRISE_BRANCH" "$ENTERPRISE_COMMIT" "$REPO_DIR/enterprise"
      clone_or_update_repo "$THEMES_REPO_URL" "$THEMES_BRANCH" "$THEMES_COMMIT" "$REPO_DIR/design-themes"
    fi

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: odoo-conf
  namespace: {{ .Release.Namespace }}
data:
  odoo.conf: |
    [options]
    addons_path = /mnt/extra-addons,
                  /mnt/repos/project/addons,
                  {{- if .Values.odoo.enterprise }}
                  /mnt/repos/enterprise,
                  /mnt/repos/design-themes
                  {{- end }}
    data_dir = /var/lib/odoo
    ; admin_passwd = admin
    ; csv_internal_sep = ,
    ; db_maxconn = 64
    ; db_name = False
    ; db_template = template1
    ; dbfilter = .*
    ; debug_mode = False
    ; email_from = False
    ; limit_memory_hard = 2684354560
    ; limit_memory_soft = 2147483648
    ; limit_request = 8192
    ; limit_time_cpu = 60
    ; limit_time_real = 120
    ; list_db = True
    ; log_db = False
    ; log_handler = [':INFO']
    ; log_level = info
    ; logfile = None
    ; longpolling_port = 8072
    ; max_cron_threads = 2
    ; osv_memory_age_limit = 1.0
    ; osv_memory_count_limit = False
    ; smtp_password = False
    ; smtp_port = 25
    ; smtp_server = localhost
    ; smtp_ssl = False
    ; smtp_user = False
    ; workers = 0
    ; xmlrpc = True
    ; xmlrpc_interface =
    ; xmlrpc_port = 8069
    ; xmlrpcs = True
    ; xmlrpcs_interface =
    ; xmlrpcs_port = 8071
