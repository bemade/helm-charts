apiVersion: v1
kind: ConfigMap
metadata:
  name: pull-production-db
  namespace: {{ .Release.Namespace }}
data:
  pull-production-db.sh: |
    #!/bin/bash

    if [ ! -f /mnt/prod-backup/done ]; then
      apk add --no-cache curl

      BACKUP_FILE="/mnt/prod-backup/backup.zip"
      EXTRACT_DIR="/mnt/prod-backup/unzipped"


      if [ -f "$BACKUP_FILE" ]; then
        rm "$BACKUP_FILE"
      fi
      curl -o "$BACKUP_FILE" -X POST \
        -F "master_pwd=$MASTER_PW" \
        -F"name=$PROD_DB" \
        -F "backup_format=zip" \
        "http://$PROD_HOST/web/database/backup"

      if [ ! -d $EXTRACT_DIR ]; then
        mkdir -p $EXTRACT_DIR
      else
        rm -rf $EXTRACT_DIR/*
      fi

      unzip "$BACKUP_FILE" -d "$EXTRACT_DIR"
      rm "$BACKUP_FILE"
      chmod -R 777 /mnt/prod-backup
    fi

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: restore-db
  namespace: {{ .Release.Namespace }}
data:
  restore-db.sh: |
    #!/bin/bash
    if [ ! -f /mnt/prod-backup/done ]; then

      BACKUP_FILE="/mnt/prod-backup/backup.zip"
      EXTRACT_DIR="/mnt/prod-backup/unzipped"

      # Function to restore the database
      restore_database() {
        echo "Restoring database $DB_NAME..."
        createdb -U "$PG_USER" -h "$PG_HOST" "$DB_NAME"
        psql -U "$PG_USER" -h "$PG_HOST" -d "$DB_NAME" -f "$EXTRACT_DIR/dump.sql"
      }

      # Function to copy the filestore
      copy_filestore() {
        echo "Copying filestore to $FILESTORE_DEST_DIR/$DB_NAME..."
        if [ ! -d "$FILESTORE_DEST_DIR" ]; then
          mkdir -p "$FILESTORE_DEST_DIR" ]
        fi
        cp -r "$EXTRACT_DIR/filestore" "$FILESTORE_DEST_DIR/$DB_NAME"
      }

      # Check if the database already exists
      if psql -U "$PG_USER" -h "$PG_HOST" -lqt | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
        echo "Database $DB_NAME already exists. Dropping database."
        dropdb -U "$PG_USER" -h "$PG_HOST" "$DB_NAME"
      fi
      restore_database

      # Check if the filestore for the database already exists
      if [ -d "$FILESTORE_DEST_DIR/$DB_NAME" ]; then
        echo "Filestore for $DB_NAME already exists. Deleting."
        rm -rf "$FILESTORE_DEST_DIR/$DB_NAME"
      fi
      echo "Copying filestore..."
      copy_filestore
      chown -R odoo:odoo /var/lib/odoo

      touch /mnt/prod-backup/done
    fi

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: init-db-script
  namespace: {{ .Release.Namespace }}
data:
  init-db-user.sh: |
    #!/bin/bash
    set -e

    # Environment variables passed to the container
    HOST=${HOST}
    USER=${USER}
    PASSWORD=${PASSWORD}

    psql -v ON_ERROR_STOP=1 --host="$HOST" --username="postgres" --dbname="postgres" <<-EOSQL
    DO \$\$
    BEGIN
      IF NOT EXISTS (SELECT FROM pg_catalog.pg_user WHERE usename = '$USER') THEN
        CREATE USER $USER WITH PASSWORD '$PASSWORD' CREATEDB;
      END IF;
    END
    \$\$;
    EOSQL

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: git-pull-addons
  namespace: {{ .Release.Namespace }}
data:
  git-pull-addons.sh: |
    #!/bin/bash
    set -e

    #!/bin/bash
    set -e

    REPO_DIR="/mnt/repo"
    EXTRA_ADDONS_DIR="/mnt/extra-addons"

    # Clear the /mnt/extra-addons directory
    rm -rf $EXTRA_ADDONS_DIR/*
    mkdir -p $EXTRA_ADDONS_DIR

    # Function to clone or update a repo
    clone_or_update_repo() {
      local repo_url=$1
      local branch=$2
      local commit=$3
      local target_dir=$4

      if [ -d "$target_dir/.git" ]; then
        echo "Repository $repo_url already exists. Fetching latest changes."
        cd $target_dir
        git fetch origin $branch
        if [ -n "$commit" ]; then
          git reset --hard $commit
        else
          git reset --hard origin/$branch
        fi
      else
        echo "Cloning repository $repo_url."
        git clone --recursive -b $branch $repo_url $target_dir
        cd $target_dir
        if [ -n "$commit" ]; then
          git reset --hard $commit
        fi
      fi

      # Update and initialize submodules
      echo "Updating submodules for $repo_url..."
      if ! git submodule update --init --recursive; then
        echo "Submodule update failed. Attempting to reset submodules..."
        git submodule deinit --all --force
        git submodule sync --recursive
        git submodule update --init --recursive --force
        if ! git submodule update --init --recursive --force; then
          echo "Submodule update failed after retry. Cleaning and reinitializing submodules."
          git submodule foreach --recursive 'rm -rf $toplevel/$sm_path'
          git submodule update --init --recursive --force
        fi
      fi
      echo "Submodules updated successfully for $repo_url."
    }

    # Clone or update the main Odoo repository
    clone_or_update_repo $REPO_URL $BRANCH $COMMIT $REPO_DIR

    # Optionally clone or update the Odoo enterprise repository
    if [ -n "$ENTERPRISE_BRANCH" ] || [ -n "$ENTERPRISE_COMMIT" ]; then
      ENTERPRISE_REPO_URL="git@github.com:odoo/enterprise.git"
      clone_or_update_repo $ENTERPRISE_REPO_URL $ENTERPRISE_BRANCH $ENTERPRISE_COMMIT "$REPO_DIR/enterprise"
      ln -s "$REPO_DIR/enterprise/*" "$EXTRA_ADDONS_DIR/"
    fi

    # Link addons from the main repo to /mnt/extra-addons
    ln -s "$REPO_DIR/addons/*" "$EXTRA_ADDONS_DIR/"
